#! /usr/bin/env python3

from typing import List
from operator import eq
from string import Template
from argparse import ArgumentParser
from pathlib import Path

from rosidl_generator_cpp import msg_type_to_cpp
from rosidl_runtime_py.utilities import get_namespaced_type
from rosidl_parser.definition import NamespacedType, AbstractNestableType
from rosidl_runtime_py.import_message import import_message_from_namespaced_type as instanciate

# Moved in rosidl_pycommon after humble
from rosidl_cmake import convert_camel_case_to_lower_case_underscore


TEMPLATE_FILE = Template('''// File generated by ${generator}. Do not manually change.

#ifndef GENERATED_${namespaced_type_uppersnake}_PYBIND_CASTERS_HPP
#define GENERATED_${namespaced_type_uppersnake}_PYBIND_CASTERS_HPP

#include <memory>

#include "pybind11/pybind11.h"
#include "pybind11/stl.h"
#include "pybind11/eigen.h"
#include "pybind11/operators.h"

#include "${namespaced_type_slash}.hpp"

static inline bool is_ros_msg_type(pybind11::handle src,
                                   const std::string &msg_type_name) {
  return pybind11::hasattr(src, "__module__") and src.attr("__module__").cast<std::string>() == msg_type_name;
}


namespace pybind11
{
namespace detail
{

using ContainerAllocator = std::allocator<void>;

${casters}

}  // namespace detail
}  // namespace pybind11

# endif  // GENERATED_${namespaced_type_uppersnake}_PYBIND_CASTERS_HPP
''')

TEMPLATE_CASTER = Template('''template <>
struct type_caster<${cpp_type}> {
 public:
  PYBIND11_TYPE_CASTER(${cpp_type}, const_name("${cpp_type}"));
  bool load(handle src, bool) {
    if (!is_ros_msg_type(src, "${module}")) {
      return false;
    }
    ${fields_load}
    return true;
  }

  static handle cast(${cpp_type} cpp_msg,
                     return_value_policy /* policy */,
                     handle /* parent */) {
    object mod = module::import("${module}");
    object MsgType = mod.attr("${py_type}");
    object msg = MsgType();
    ${fields_cast}
    msg.inc_ref();
    return msg;
  }
};''')

TEMPLATE_FIELDS_LOAD = Template('value.${field} = src.attr("${field}").cast<${field_type}>();')
TEMPLATE_FIELDS_CAST = Template('msg.attr("${field}") = pybind11::cast(cpp_msg.${field});')


def resolve_types(msg_typename: str) -> List[NamespacedType]:
    def _resolve_types(type_: AbstractNestableType) -> List[NamespacedType]:
        if isinstance(type_, NamespacedType):
            # pkg/msg/Message types
            msg = instanciate(type_)
            return [type_] + [t for subtype in msg.SLOT_TYPES for t in _resolve_types(subtype)]
        else:
            # Strings, ints, floats, ...
            return []

    # Recursively search for namespaced types
    resolved_types = _resolve_types(get_namespaced_type(msg_typename))

    # After the recursive type search, there are a lot of duplicates
    # (and set is not supported so doing it by hand)
    unique_types = []
    for type_ in resolved_types:
        if not any(type_==utype for utype in unique_types):
            unique_types.append(type_)

    return unique_types


def gen_caster(type_: NamespacedType) -> str:
    instanciated_message = instanciate(type_)
    field_names = list(instanciated_message.get_fields_and_field_types().keys())
    field_types = list(map(msg_type_to_cpp, instanciated_message.SLOT_TYPES))

    fields_cast = '\n    '.join(TEMPLATE_FIELDS_CAST.substitute(field=field) 
                                for field in field_names)
    fields_load = '\n    '.join(TEMPLATE_FIELDS_LOAD.substitute(field=field, field_type=field_type)
                                for field, field_type in zip(field_names, field_types))

    caster = TEMPLATE_CASTER.substitute(
        cpp_type=msg_type_to_cpp(type_),
        py_type=type_.name,
        module=instanciated_message.__module__,
        fields_load=fields_load,
        fields_cast=fields_cast,
    )

    return caster


def gen_caster_file(types: List[NamespacedType]) -> str:
    origin_type = types[0]
    typename_snake = convert_camel_case_to_lower_case_underscore(origin_type.name)
    namespaced_name_snake = (*origin_type.namespaces, typename_snake)
    
    casters = '\n\n'.join(map(gen_caster, reversed(types)))
    return TEMPLATE_FILE.substitute(
        namespaced_type_uppersnake='_'.join(namespaced_name_snake).upper(),
        namespaced_type_slash='/'.join(namespaced_name_snake),
        casters=casters,
        generator=Path(__file__).name,
    )


def main():
    parser = ArgumentParser('Generates a header file casting ROS interfaces '
                            'from python to c++ and back using pybind11')
    parser.add_argument('MSGTYPE', help='Namespaced ROS interface type '
                                        '(e.g. "nav_msgs/msg/Odometry"')
    args = parser.parse_args()
    types = resolve_types(args.MSGTYPE)
    print(gen_caster_file(types))


if __name__ == '__main__':
    main()
